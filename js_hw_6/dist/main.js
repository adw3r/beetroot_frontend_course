(()=>{class t{constructor(t={}){this.data=t,this._name=t.name,this._quantity=t.quantity,this._status=t.status,this._price=t.price}get status(){return this._status}set status(t){this._status=t}get name(){return this._name}set name(t){this._name=t}get quantity(){return this._quantity}set quantity(t){this._quantity=t}get price(){return this._price}set price(t){this._price=t}get totalPrice(){return this.quantity*this.price}}const s=new class{constructor(t=[]){this.products=t}showProductsSorted(t){return this.products.sort(t)}filterProducts(t){let s=this.products.filter(t);return this.products=s,s}setStatusForProduct(t,s){this.products.forEach((e=>{e.name===s&&(e.status=t)}))}addProduct=function(t){this.products.forEach((s=>{s.name===t.name&&(s.quantity+=t.quantity)}))}}([new t({name:"Apple",quantity:10,status:"pending",price:100}),new t({name:"Orange",status:"pending",price:300,quantity:30}),new t({name:"Pineapple",status:"done",price:300,quantity:30}),new t({name:"Banana",status:"pending",price:200,quantity:20})]);console.log("Виводити весь список на екран таким чином, щоб спочатку йшли продукти, що ще не придбані, а потім - ті, що вже придбали."),console.log(s.showProductsSorted(((t,s)=>"pending"===t.status&&"done"===s.status?-1:"done"===t.status&&"pending"===s.status?1:0))),console.log("Покупка продукту. Функція приймає назву продукту і відзначає його як придбаний."),s.setStatusForProduct("done","Apple"),console.log(s.products),console.log("Видалення продукту зі списку (видалення повинно проводитися шляхом створення нового масиву, в якому продукт, що ми шукаємо, буде відсутнім)"),s.filterProducts((t=>"Apple"!==t.name)),console.log(s.products),console.log("Додавання покупки в список. Враховуй, що при додаванні покупки з уже існуючим в списку продуктом, необхідно збільшувати кількість в існуючій покупці, а не додавати нову. При цьому також повинна змінитися сума, наприклад, якщо ціна за одиницю 12, а кількості товарів стало 2, то сума буде 24."),s.addProduct(new t({name:"Orange",quantity:30,status:"pending",price:300})),console.log(s.products),console.log("Підрахунок суми всіх продуктів (враховуючи кількість кожного) в списку."),s.totalPrice=function(){let t=0;return this.products.forEach((s=>{t+=s.totalPrice})),t},console.log(s.totalPrice()),console.log("Підрахунок суми всіх (не) придбаних продуктів."),s.totalPriceWithStatus=function(t){let s=0;return this.products.forEach((e=>{e.status===t&&(s+=e.totalPrice)})),s},console.log(s.totalPriceWithStatus("done")),s.sortByTotalPrice=function(t="asc"){return this.products.sort(((s,e)=>{const o=s.totalPrice-e.totalPrice;return"asc"===t?o:-o}))},console.log(s.sortByTotalPrice("desc"))})();